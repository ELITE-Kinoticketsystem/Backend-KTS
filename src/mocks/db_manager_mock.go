// Code generated by MockGen. DO NOT EDIT.
// Source: ./src/managers/db_manager.go
//
// Generated by this command:
//
//	mockgen -source=./src/managers/db_manager.go -destination=./src/mocks/db_manager_mock.go -package=mocks
//
// Package mocks is a generated GoMock package.
package mocks

import (
	sql "database/sql"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockDatabaseManagerI is a mock of DatabaseManagerI interface.
type MockDatabaseManagerI struct {
	ctrl     *gomock.Controller
	recorder *MockDatabaseManagerIMockRecorder
}

// MockDatabaseManagerIMockRecorder is the mock recorder for MockDatabaseManagerI.
type MockDatabaseManagerIMockRecorder struct {
	mock *MockDatabaseManagerI
}

// NewMockDatabaseManagerI creates a new mock instance.
func NewMockDatabaseManagerI(ctrl *gomock.Controller) *MockDatabaseManagerI {
	mock := &MockDatabaseManagerI{ctrl: ctrl}
	mock.recorder = &MockDatabaseManagerIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDatabaseManagerI) EXPECT() *MockDatabaseManagerIMockRecorder {
	return m.recorder
}

// CheckIfExists mocks base method.
func (m *MockDatabaseManagerI) CheckIfExists(query string, args ...any) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []any{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CheckIfExists", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckIfExists indicates an expected call of CheckIfExists.
func (mr *MockDatabaseManagerIMockRecorder) CheckIfExists(query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckIfExists", reflect.TypeOf((*MockDatabaseManagerI)(nil).CheckIfExists), varargs...)
}

// ExecuteQuery mocks base method.
func (m *MockDatabaseManagerI) ExecuteQuery(query string, args ...any) (*sql.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []any{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecuteQuery", varargs...)
	ret0, _ := ret[0].(*sql.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteQuery indicates an expected call of ExecuteQuery.
func (mr *MockDatabaseManagerIMockRecorder) ExecuteQuery(query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteQuery", reflect.TypeOf((*MockDatabaseManagerI)(nil).ExecuteQuery), varargs...)
}

// ExecuteQueryRow mocks base method.
func (m *MockDatabaseManagerI) ExecuteQueryRow(query string, args ...any) *sql.Row {
	m.ctrl.T.Helper()
	varargs := []any{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecuteQueryRow", varargs...)
	ret0, _ := ret[0].(*sql.Row)
	return ret0
}

// ExecuteQueryRow indicates an expected call of ExecuteQueryRow.
func (mr *MockDatabaseManagerIMockRecorder) ExecuteQueryRow(query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteQueryRow", reflect.TypeOf((*MockDatabaseManagerI)(nil).ExecuteQueryRow), varargs...)
}

// ExecuteStatement mocks base method.
func (m *MockDatabaseManagerI) ExecuteStatement(query string, args ...any) (sql.Result, error) {
	m.ctrl.T.Helper()
	varargs := []any{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecuteStatement", varargs...)
	ret0, _ := ret[0].(sql.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteStatement indicates an expected call of ExecuteStatement.
func (mr *MockDatabaseManagerIMockRecorder) ExecuteStatement(query any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteStatement", reflect.TypeOf((*MockDatabaseManagerI)(nil).ExecuteStatement), varargs...)
}
